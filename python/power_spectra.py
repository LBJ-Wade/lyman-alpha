import math as mh
import random as rd
import numpy as np
import numpy.random as npr
import scipy.integrate as spi
import copy as cp
import astropy.units as u
import spectra as sa
import griddedspectra as gs
import randspectra as rs
import sys

from utils import *

class PowerSpectrum:
    """Class to evaluate 1D and 3D versions of a power spectrum"""
    def _integrand(self,k_perp,k_z):
        """Integrand calculated as given in arxiv:1306.5896"""
        k3D = np.sqrt(k_perp ** 2 + k_z ** 2)
        Pk3D = self.evaluate3d(k3D)
        return (Pk3D * k_perp) / (2. * mh.pi)

    def evaluate1d(self, k_x_vec, k_y_vec, k_z_vec):
        k_perp_min = np.sqrt(k_x_vec[0] ** 2 + k_y_vec[0] ** 2)
        k_perp_max = np.sqrt(np.max(k_x_vec) ** 2 + np.max(k_y_vec) ** 2)
        pow_kz = np.zeros(k_z_vec.shape[0])
        for i in range(k_z_vec.shape[0]):
            pow_kz[i] = spi.quad(self._integrand, k_perp_min.value, k_perp_max.value, (k_z_vec[i].value,))[0]
        return pow_kz


class PowerLawPowerSpectrum(PowerSpectrum):
    """Sub-class to evaluate a power law power spectrum"""
    def __init__(self,pow_index,pow_pivot,pow_amp):
        assert is_astropy_quantity(pow_pivot)
        self._pow_index = pow_index
        self._pow_pivot = pow_pivot
        self._pow_amp = pow_amp

    def _evaluate3d_isotropic(self, k):
        Pk = self._pow_amp * (k / self._pow_pivot) ** self._pow_index
        if is_astropy_quantity(k):
            return Pk
        else:
            return Pk.value


class IsotropicPowerLawPowerSpectrum(PowerLawPowerSpectrum):
    """Sub-class of PowerLawPowerSpectrum to evaluate an isotropic version of a power law power spectrum"""
    def __init__(self, pow_index, pow_pivot, pow_amp):
        super(IsotropicPowerLawPowerSpectrum, self).__init__(pow_index, pow_pivot, pow_amp)

    def evaluate3d(self, k, *_, **__):
        return self._evaluate3d_isotropic(k)


class AnisotropicPowerLawPowerSpectrum(PowerLawPowerSpectrum):
    """Sub-class of PowerLawPowerSpectrum to evaluate an anisotropic correction to a power law power spectrum"""
    def __init__(self,pow_index,pow_pivot,pow_amp,mu_coefficients): #CURRENTLY WRITTEN FOR CONSTANT BIASES
        super(AnisotropicPowerLawPowerSpectrum, self).__init__(pow_index,pow_pivot,pow_amp)
        self._mu_coefficients = mu_coefficients #tuple from highest order to zeroth order (constant)

    def evaluate3d(self,k,mu, *_, **__):
        return self._evaluate3d_isotropic(k) * np.polyval(self._mu_coefficients,mu)


class CAMBPowerSpectrum(PowerSpectrum): #Sub-class to be created
    """Sub-class to evaluate a power spectrum as generated by CAMB"""
    def __init__(self,fname):
        pass

    def evaluate3d(self,k, *_, **__):
        return 0