import math as mh
import random as rd
import numpy as np
import numpy.random as npr
import scipy.integrate as spi
import copy as cp
import astropy.units as u
import spectra as sa
import griddedspectra as gs
import randspectra as rs
import sys

def k_i(i,n_samp,voxel_velocity):
    if i == 'z':
        return np.fft.fftfreq(n_samp, d=voxel_velocity) #For the moment - don't use real approximation
    else:
        return np.fft.fftfreq(n_samp, d=voxel_velocity)

def sort_3D_to_1D(array_3D, args_1D):
    return array_3D.flatten()[args_1D]

def bin_data(array_1D, n_bins):
    shortened_length = int(mh.floor(array_1D.size / n_bins) * n_bins)
    return np.mean(array_1D[:shortened_length].reshape((n_bins, -1)), axis=-1) #, [np.mean(array_1D[shortened_length:])]))

def snapshot_to_power_3D_binned(snap_num,snap_dir,grid_samps,spectrum_resolution,n_bins,reload_snapshot=True,norm=True):
    box_instance = SimulationBox(snap_num,snap_dir,grid_samps,spectrum_resolution,reload_snapshot=reload_snapshot)
    simu_box = box_instance.skewers_realisation()
    power_instance = FourierEstimator3D(simu_box)
    k_box = box_instance.k_box()
    return power_instance.get_flux_power_3D_binned(k_box,n_bins,norm=norm)

def is_astropy_quantity(var):
    return hasattr(var,'value')


class PowerSpectrum:
    """Class to evaluate 1D and 3D versions of a power spectrum"""
    def _integrand(self,k_perp,k_z):
        """Integrand calculated as given in arxiv:1306.5896"""
        k3D = np.sqrt(k_perp ** 2 + k_z ** 2)
        Pk3D = self.evaluate3d(k3D)
        return (Pk3D * k_perp) / (2. * mh.pi)

    def evaluate1d(self, k_x_vec, k_y_vec, k_z_vec):
        k_perp_min = np.sqrt(k_x_vec[0] ** 2 + k_y_vec[0] ** 2)
        k_perp_max = np.sqrt(np.max(k_x_vec) ** 2 + np.max(k_y_vec) ** 2)
        pow_kz = np.zeros(k_z_vec.shape[0])
        for i in xrange(k_z_vec.shape[0]):
            pow_kz[i] = spi.quad(self._integrand, k_perp_min.value, k_perp_max.value, (k_z_vec[i].value,))[0]
        return pow_kz


class PowerLawPowerSpectrum(PowerSpectrum):
    """Sub-class to evaluate a power law power spectrum"""
    def __init__(self,pow_index,pow_pivot,pow_amp):
        assert is_astropy_quantity(pow_pivot)
        self._pow_index = pow_index
        self._pow_pivot = pow_pivot
        self._pow_amp = pow_amp

    def evaluate3d(self,k):
        Pk = self._pow_amp * (k / self._pow_pivot) ** self._pow_index
        if is_astropy_quantity(k):
            return Pk
        else:
            return Pk.value


class CAMBPowerSpectrum(PowerSpectrum): #Sub-class to be created
    """Sub-class to evaluate a power spectrum as generated by CAMB"""
    def __init__(self,fname):
        pass

    def evaluate3d(self,k):
        return 0


class Box:
    """Class to generate a box of fluctuations"""
    def k_i(self,i):
        return k_i(i,self._n_samp[i],self.voxel_velocities[i])

    def k_box(self):
        x = self.k_i('x')[:,np.newaxis,np.newaxis]
        y = self.k_i('y')[np.newaxis,:,np.newaxis]
        z = self.k_i('z')[np.newaxis,np.newaxis,:]
        return np.sqrt(x**2 + y**2 + z**2)


class GaussianBox(Box):
    """Sub-class to generate a box of fluctuations from a Gaussian random field"""
    def __init__(self,x_max,n_samp,redshift,H0,omega_m):
        self._x_max = x_max #Tuples for 3 dimensions
        self._n_samp = n_samp
        self._redshift = redshift
        self._H0 = H0
        self._omega_m = omega_m

        self.voxel_lens = {}
        self.voxel_velocities = {}
        for i in ['x','y','z']:
            self.voxel_lens[i] = self._x_max[i] / (self._n_samp[i] - 1)
            self.voxel_velocities[i] = self.voxel_lens[i] * self.hubble_z()

    def hubble_z(self):
        return self._H0 * np.sqrt(self._omega_m * (1 + self._redshift) ** 3 + 1. - self._omega_m)

    def gauss_realisation(self,pow_index,pow_pivot,pow_amp): #CHANGE SO NOT HARD-CODED TO POWER LAW
        k_box = self.k_box()
        print "Generated Fourier-space box of k-values"
        box_spectra = PowerLawPowerSpectrum(pow_index,pow_pivot,pow_amp)
        gauss_k=np.sqrt(0.5*box_spectra.evaluate3d(k_box))*(npr.standard_normal(size=k_box.shape)+npr.standard_normal(size=k_box.shape)*1.j)
        gauss_k[k_box == 0.] = 0. #Zeroing the mean
        print "Generated Fourier-space box of Gaussian perturbations"
        gauss_x = np.fft.ifftn(gauss_k, s=(self._n_samp['x'], self._n_samp['y'], self._n_samp['z']), axes=(0, 1, 2))
        print "Transformed to real-space box of Gaussian perturbations"

        return gauss_k


class SimulationBox(Box):
    """Sub-class to generate a box of Lyman-alpha spectra drawn from Simeon's simulations"""
    def __init__(self,snap_num,snap_dir,grid_samps,spectrum_resolution,reload_snapshot=True):
        self._n_samp = {}
        self._n_samp['x'] = grid_samps
        self._n_samp['y'] = grid_samps

        self.voxel_velocities = {}

        self._snap_num = snap_num
        self._snap_dir = snap_dir
        self._grid_samps = grid_samps
        self._spectrum_resolution = spectrum_resolution
        self._reload_snapshot = reload_snapshot

        self.spectra_savefile = 'gridded_spectra_%i_%i.hdf5' %(self._grid_samps,self._spectrum_resolution.value)

        self.element = 'H'
        self.ion = 1
        self.line_wavelength = 1215 * u.angstrom

        gr = gs.GriddedSpectra(self._snap_num, self._snap_dir, nspec=self._grid_samps, res=self._spectrum_resolution.value,savefile=self.spectra_savefile,reload_file=self._reload_snapshot)
        self._n_samp['z'] = int(gr.vmax / gr.dvbin)
        self.voxel_velocities['x'] = (gr.vmax / self._n_samp['x']) * (u.km / u.s)
        self.voxel_velocities['y'] = (gr.vmax / self._n_samp['y']) * (u.km / u.s)
        self.voxel_velocities['z'] = gr.dvbin * (u.km / u.s)
        print "Size of voxels in velocity units =", self.voxel_velocities, "\n"

    def skewers_realisation(self):
        gr = gs.GriddedSpectra(self._snap_num,self._snap_dir,nspec=self._grid_samps,res=self._spectrum_resolution.value,savefile=self.spectra_savefile,reload_file=self._reload_snapshot)
        tau = gr.get_tau(self.element,self.ion,int(self.line_wavelength.value)) #SLOW if not reloading
        gr.save_file() #Save spectra to file
        delta_flux = np.exp(-1.*tau) / np.mean(np.exp(-1.*tau)) - 1.
        return delta_flux.reshape((self._grid_samps,self._grid_samps,-1))


class FourierEstimator(object): #Need object dependence so sub-classes can inherit __init__
    """Class to estimate power spectra from a box of fluctuations"""
    def __init__(self,gauss_box):
        self._gauss_box = gauss_box


class FourierEstimator1D(FourierEstimator):
    """Sub-class to calculate 1D power spectra"""
    def __init__(self,gauss_box,n_skewers):
        super(FourierEstimator1D, self).__init__(gauss_box)
        self._nskewers = n_skewers

    def samples_1D(self):
        return rd.sample(np.arange(self._gauss_box.shape[0] * self._gauss_box.shape[1]), self._nskewers)

    def skewers_1D(self):
        return self._gauss_box.reshape((self._gauss_box.shape[0] * self._gauss_box.shape[1], -1))[self.samples_1D(), :]

    #COURTESY OF SIMEON BIRD
    def get_flux_power_1D(self):
        delta_flux = self.skewers_1D()

        df_hat = np.fft.fft(delta_flux, axis=1)
        flux_power = np.real(df_hat) ** 2 + np.imag(df_hat) ** 2
        #Average over all sightlines
        avg_flux_power = np.mean(flux_power, axis=0)

        return avg_flux_power


class FourierEstimator3D(FourierEstimator):
    """Sub-class to calculate 3D power spectra"""
    def __init__(self,gauss_box,grid=True,x_step=1,y_step=1,n_skewers=0):
        super(FourierEstimator3D, self).__init__(gauss_box)
        self._grid = grid
        self._x_step = x_step
        self._y_step = y_step
        self._n_skewers = n_skewers

    def samples_3D(self):
        if self._grid == True:
            return np.arange(0,self._gauss_box.shape[0],self._x_step),np.arange(0,self._gauss_box.shape[1],self._y_step)
        elif self._grid == False:
            n_zeros = (self._gauss_box.shape[0] * self._gauss_box.shape[1]) - self._n_skewers
            return rd.sample(np.arange(self._gauss_box.shape[0] * self._gauss_box.shape[1]), n_zeros) #Sampling zeros

    def skewers_3D(self):
        if self._grid == True:
            xy_samps = self.samples_3D()
            return self._gauss_box[xy_samps[0],:,:][:,xy_samps[1],:]
        elif self._grid == False:
            skewers = cp.deepcopy(self._gauss_box)
            skewers = skewers.reshape((self._gauss_box.shape[0] * self._gauss_box.shape[1], -1))
            skewers[self.samples_3D(), :] = 0. + 0.j
            skewers = skewers.reshape(self._gauss_box.shape[0], self._gauss_box.shape[1], -1)
            return skewers

    def get_flux_power_3D(self,norm=True):
        flux_real = self.skewers_3D()
        if norm == False:
            norm_fac = 1.
        elif norm == True:
            norm_fac = flux_real.size
        df_hat = np.fft.fftn(flux_real) / norm_fac
        flux_power = np.real(df_hat) ** 2 + np.imag(df_hat) ** 2
        return flux_power, df_hat

    def get_flux_power_3D_mod_k(self,k_box,norm=True):
        flux_power = self.get_flux_power_3D(norm)[0]
        k_unique = np.unique(k_box)
        power_unique = np.zeros_like(k_unique.value)
        for i in xrange(k_unique.shape[0]):
            print "Binning 3D power according to unique value of |k| #%i/%i" %(i+1,k_unique.shape[0])
            power_unique[i] = np.mean(flux_power[k_box == k_unique[i]])
        return power_unique, k_unique

    def get_flux_power_3D_binned(self,k_box,n_bins,norm=True):
        k_argsort = np.argsort(k_box,axis=None)
        k_sorted = sort_3D_to_1D(k_box, k_argsort)
        flux_power = self.get_flux_power_3D(norm)[0]
        power_sorted = sort_3D_to_1D(flux_power, k_argsort)
        return bin_data(power_sorted,n_bins), bin_data(k_sorted,n_bins)


if __name__ == "__main__":
    snap_num = int(sys.argv[1])
    snap_dir = '/Users/keir/Documents/lyman_alpha/simulations/illustris_Cosmo7_V6'
    #snap_dir = '/home/keir/Data/illustris_Cosmo7_V6'
    grid_samps = int(sys.argv[2])
    spectrum_resolution = float(sys.argv[3])*(u.km / u.s)
    n_bins = 10000
    reload_snapshot = False
    norm = True
    power_binned, k_binned = snapshot_to_power_3D_binned(snap_num,snap_dir,grid_samps,spectrum_resolution,n_bins,reload_snapshot=reload_snapshot,norm=norm)